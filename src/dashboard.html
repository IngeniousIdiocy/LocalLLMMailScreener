<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Local LLM Mail Screener</title>
  <style>
    :root {
      --bg: #05070f;
      --glass: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text: #e8ecf5;
      --muted: #9aa3b5;
      --accent: #41d6ff;
      --danger: #ef4444;
      --success: #22c55e;
      --warn: #f59e0b;
      --font: 'Space Grotesk', 'Segoe UI', system-ui, sans-serif;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      padding: 24px;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 20% 80%, rgba(65, 214, 255, 0.25), transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(255, 0, 110, 0.15), transparent 40%),
        radial-gradient(circle at 40% 40%, rgba(131, 56, 236, 0.18), transparent 45%),
        radial-gradient(circle at 90% 90%, rgba(6, 255, 165, 0.18), transparent 35%);
      filter: blur(90px);
      z-index: 0;
      pointer-events: none;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: min(1600px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .btn {
      background: var(--accent);
      border: 1px solid rgba(255,255,255,0.15);
      color: #02060f;
      padding: 8px 14px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s ease;
    }

    .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 8px 24px rgba(65,214,255,0.2); }
    .btn:active:not(:disabled) { transform: translateY(0); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn.secondary {
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-color: rgba(255,255,255,0.1);
    }

    .btn.small { padding: 5px 8px; font-size: 11px; }

    .btn.gemini-fallback {
      background: var(--danger);
      color: #fff;
    }
    .btn.gemini-fallback:hover:not(:disabled) {
      box-shadow: 0 8px 24px rgba(255,75,75,0.3);
    }

    h1 {
      font-size: 1.75rem;
      letter-spacing: -0.02em;
      font-weight: 700;
    }

    /* Health Cards Row */
    .health-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }

    .card {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 14px;
      padding: 16px 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow: hidden;
      min-width: 0;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .card-title {
      font-weight: 600;
      font-size: 15px;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .ok { background: rgba(34, 197, 94, 0.15); color: var(--success); }
    .fail { background: rgba(239, 68, 68, 0.15); color: var(--danger); }
    .warn { background: rgba(245, 158, 11, 0.15); color: var(--warn); }

    .card-meta {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    /* Stats Section */
    .stats-section .card-header {
      margin-bottom: 14px;
    }

    .config-info {
      color: var(--muted);
      font-size: 11px;
      font-family: monospace;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 60%;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .stat {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--glass-border);
      border-radius: 10px;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 88px;
    }

    .stat-label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.02em;
      margin-top: auto;
    }

    /* Notifications Section */
    .notifications-section .card-header {
      margin-bottom: 16px;
      justify-content: flex-start;
    }

    .notifications-section .card-header .card-meta {
      margin-left: auto;
    }

    .notifications-section.collapsed .notifications-grid {
      display: none;
    }

    .notifications-section.collapsed .card-header {
      margin-bottom: 0;
    }

    .card-header.clickable {
      cursor: pointer;
    }

    .card-header.clickable:hover {
      opacity: 0.85;
    }

    .collapse-toggle {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 14px;
      cursor: pointer;
      padding: 4px 8px;
      margin-left: 4px;
      transition: transform 0.2s ease;
    }

    .collapse-toggle:hover {
      color: var(--text);
    }

    .notifications-section.collapsed .collapse-toggle {
      transform: rotate(-90deg);
    }

    .notifications-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr));
      gap: 14px;
      align-items: stretch;
    }

    .notification-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 100%;
      transition: background 0.2s ease, border-color 0.2s ease;
      overflow: hidden;
      min-width: 0;
    }

    .notification-card:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.15);
    }

    .notification-card.high { border-left: 3px solid var(--danger); }
    .notification-card.normal { border-left: 3px solid var(--accent); }
    .notification-card.low { border-left: 3px solid var(--muted); }

    .notif-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 12px;
      color: var(--muted);
      gap: 8px;
      min-width: 0;
    }

    .notif-row span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .notif-row span:first-child {
      flex: 1;
      min-width: 0;
    }

    .notif-row span:last-child {
      flex-shrink: 0;
      max-width: 45%;
    }

    .notif-label {
      opacity: 0.7;
      margin-right: 3px;
    }

    .notif-field {
      font-size: 13px;
      line-height: 1.4;
      min-width: 0;
      overflow: hidden;
    }

    .notif-field .notif-label {
      color: var(--muted);
    }

    .notif-field .notif-value {
      color: var(--text);
      word-break: break-word;
    }

    .notif-field.subject {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .notif-field.subject .notif-value {
      font-weight: 600;
    }

    .notif-field.reason {
      margin-top: 4px;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .notif-field.reason .notif-value {
      opacity: 0.85;
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .notif-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-top: 10px;
      margin-top: auto;
      border-top: 1px solid rgba(255,255,255,0.06);
      gap: 8px;
      min-width: 0;
    }

    .notif-id {
      font-size: 9px;
      color: var(--muted);
      font-family: monospace;
      opacity: 0.5;
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .notif-link {
      color: var(--accent);
      text-decoration: none;
      font-size: 11px;
      font-weight: 600;
      padding: 5px 10px;
      border-radius: 6px;
      background: rgba(65,214,255,0.1);
      transition: background 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .notif-link:hover {
      background: rgba(65,214,255,0.2);
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--muted);
      grid-column: 1 / -1;
    }

    /* Analyst Section Styles */
    .analyst-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }

    /* Primary controls - flex row on desktop */
    .primary-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: stretch;
    }

    .primary-controls > .btn {
      display: flex;
      align-items: center;
    }

    /* Advanced filters toggle */
    .advanced-filters-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      padding: 8px 0;
    }

    .advanced-filters-toggle:hover {
      color: var(--text);
    }

    .advanced-filters-toggle .collapse-toggle {
      padding: 2px 4px;
      font-size: 12px;
      margin-left: 0;
      transition: transform 0.2s ease;
    }

    /* Arrow rotates when collapsed */
    .advanced-filters-toggle.collapsed .collapse-toggle {
      transform: rotate(-90deg);
    }

    /* Advanced filters content */
    .advanced-filters {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .advanced-filters.collapsed {
      display: none;
    }

    .control-group-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: stretch;
    }
    
    .control-group-row > .btn {
      display: flex;
      align-items: center;
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 120px;
    }

    .control.wide {
      flex: 1;
      min-width: 140px;
    }

    .control label {
      font-size: 11px;
      color: var(--muted);
      letter-spacing: 0.03em;
    }

    .control input, .control select, .control textarea {
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 13px;
      font-family: var(--font);
      outline: none;
      transition: border-color 0.15s ease;
      height: 30px;
    }

    .control input:focus, .control select:focus {
      border-color: var(--accent);
    }

    .control input[type="number"] {
      width: 50px;
      text-align: center;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 6px;
      height: 30px;
    }

    .toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .analyst-meta {
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }

    /* 2x2 Checkbox Grid */
    .control.checkbox-grid {
      padding: 8px 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .checkbox-2x2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 14px;
    }

    .checkbox-2x2 label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      transition: color 0.15s ease;
      white-space: nowrap;
    }

    .checkbox-2x2 label:hover {
      color: var(--text);
    }

    .checkbox-2x2 input[type="checkbox"] {
      width: 12px;
      height: 12px;
      accent-color: var(--accent);
    }

    /* Segmented Toggle Control */
    .segment-toggle {
      display: inline-flex;
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 2px;
      gap: 2px;
    }

    .segment-toggle button {
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 5px 12px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
      font-family: var(--font);
    }

    .segment-toggle button:hover:not(.active) {
      color: var(--text);
      background: rgba(255,255,255,0.05);
    }

    .segment-toggle button.active {
      background: var(--accent);
      color: #02060f;
    }

    .list-chip {
      display: inline-flex;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--glass-border);
      font-size: 12px;
      margin: 3px;
    }

    /* Analyst Section */
    .analyst-header-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .analyst-header-title {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .analyst-section.collapsed .analyst-panel-content {
      display: none;
    }

    .analyst-section.collapsed .card-header {
      margin-bottom: 0;
    }

    .analyst-section.collapsed .collapse-toggle {
      transform: rotate(-90deg);
    }

    .analyst-panel-content {
      display: flex;
      flex-direction: column;
    }

    .analyst-panel-subheader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .grid-halves {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      margin-top: 12px;
      align-items: start;
    }

    @media (max-width: 800px) {
      .grid-halves {
        grid-template-columns: 1fr;
      }
    }

    .mono {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .pill-outline {
      border: 1px solid var(--glass-border);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: var(--muted);
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }

    .list-scroll {
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding-right: 4px;
      flex: 1;
      min-height: 0;
    }

    .list-scroll.wrap {
      flex-direction: row;
      flex-wrap: wrap;
      gap: 6px;
      flex: 0 0 auto;
      max-height: 120px;
    }

    .list-scroll::-webkit-scrollbar {
      width: 6px;
    }

    .list-scroll::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.03);
      border-radius: 3px;
    }

    .list-scroll::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.15);
      border-radius: 3px;
    }

    .output-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 14px;
      margin-top: 14px;
    }

    @media (max-width: 1100px) {
      .output-row {
        grid-template-columns: 1fr;
      }
    }

    .claude-pane {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
    }

    .signals-pane {
      /* No overflow - content determines height */
      overflow: visible;
      /* Span full width of grid when it's the only item */
      grid-column: 1 / -1;
    }
    
    .signals-pane .list-scroll {
      /* Disable scroll in signals - show all content */
      overflow: visible;
      max-height: none;
    }
    
    .signals-pane .list-scroll.wrap {
      max-height: none;
    }
    

.charts-card {
  background: var(--glass);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 14px 16px;
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.chart-select-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.chart-select-row select {
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text);
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 13px;
  min-width: 220px;
}

.chart-range-label {
  font-size: 12px;
  color: var(--muted);
  margin-left: 8px;
}

.chart-area {
  background: rgba(0,0,0,0.25);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  padding: 10px;
  min-height: 260px;
  display: none;
}

.chart-area.active {
  display: block;
}

    .claude-output-section {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 14px;
    }

    .claude-pane-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .claude-pane-title {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .claude-pane-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .claude-output-content {
      margin-top: 12px;
    }

    .claude-output-content .mono {
      background: rgba(0,0,0,0.4);
      padding: 14px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.06);
      max-height: 50vh;
      overflow: auto;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
    }

.claude-output-content .rendered {
  background: rgba(0,0,0,0.25);
  padding: 16px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.08);
  line-height: 1.6;
  max-height: 50vh;
  overflow: auto;
  word-break: break-word;
  overflow-wrap: anywhere;
}

.claude-output-content .rendered a {
  color: #a5c8ff;
  font-weight: 700;
  text-decoration: none;
  border-bottom: 1px solid rgba(165, 200, 255, 0.25);
  white-space: nowrap;
}

.claude-output-content .rendered a:hover {
  color: #cbe1ff;
  border-bottom-color: rgba(203, 225, 255, 0.6);
}

.claude-output-content .rendered a:visited {
  color: #9a7ad6;
  border-bottom-color: rgba(154, 122, 214, 0.45);
}

    .rendered h1,
    .rendered h2,
    .rendered h3,
    .rendered h4 {
      margin: 12px 0 8px 0;
      font-size: 15px;
      color: var(--text);
    }

    .rendered h1:first-child,
    .rendered h2:first-child {
      margin-top: 0;
    }

    .rendered ul, .rendered ol {
      padding-left: 20px;
      margin: 8px 0;
    }

    .rendered li {
      margin-bottom: 6px;
      color: var(--text);
      opacity: 0.9;
    }

    .rendered p {
      margin: 8px 0;
    }

    .rendered strong {
      color: var(--accent);
    }

    .section-spacer {
      margin-top: 14px;
    }

    .grid-halves.section-spacer {
      margin-top: 12px;
    }

    /* Signal bars */
    .signal-section {
      margin-bottom: 12px;
    }

    .signal-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 6px;
    }

    .signal-items {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .signal-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      font-size: 12px;
      color: var(--text);
    }

    .signal-chip .count {
      background: rgba(65,214,255,0.2);
      color: var(--accent);
      padding: 1px 5px;
      border-radius: 4px;
      font-size: 11px;
    }

    .signal-chip.clickable {
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    .signal-chip.clickable:hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--accent);
    }

    .signal-chip.clickable.active {
      background: rgba(65,214,255,0.15);
      border-color: var(--accent);
      font-weight: 600;
    }


    /* GPU Panel */
    .gpu-section .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 14px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .gpu-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .gpu-name {
      font-size: 12px;
      color: var(--muted);
      font-family: monospace;
    }

    .gpu-current-stats {
      display: flex;
      gap: 20px;
      font-size: 14px;
    }

    .gpu-stat {
      display: flex;
      align-items: baseline;
      gap: 6px;
    }

    .gpu-stat-label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
    }

    .gpu-stat-value {
      font-weight: 700;
      font-size: 18px;
    }

    .gpu-stat-value.high {
      color: var(--danger);
    }

    .gpu-stat-value.warn {
      color: var(--warn);
    }

    .gpu-chart-container {
      background: rgba(0,0,0,0.25);
      border: 1px solid var(--glass-border);
      border-radius: 10px;
      padding: 12px;
      height: 160px;
      position: relative;
    }

    .gpu-chart-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .gpu-x-axis {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--muted);
    }

    #gpu-chart {
      width: 100%;
      height: calc(100% - 24px);
      display: block;
      border: 1px solid rgba(255, 255, 255, 0.8);
      border-radius: 4px;
      box-sizing: border-box;
    }

    .gpu-legend {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: -5px;
      font-size: 11px;
      color: var(--muted);
    }

    .gpu-legend-block {
      width: 12px;
      height: 12px;
      background: rgba(65, 214, 255, 0.9);
      border-radius: 2px;
      flex-shrink: 0;
    }

    @media (max-width: 640px) {
      .gpu-current-stats {
        flex-wrap: wrap;
        gap: 12px;
      }
      .gpu-stat-value {
        font-size: 16px;
      }
    }

    /* Responsive */
    @media (max-width: 900px) {
      .health-row {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      body { padding: 16px; }
      h1 { font-size: 1.4rem; }
      .stat-value { font-size: 20px; }
      .notifications-grid {
        grid-template-columns: 1fr;
      }

      /* Analyst mode mobile layout - 2x3 grid with equal columns */
      .primary-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .primary-controls .control {
        min-width: unset;
        width: 100%;
      }

      .primary-controls .load-btn-cell {
        display: flex;
        flex-direction: column;
      }

      .primary-controls .load-btn-cell .btn {
        flex: 1;
        width: 100%;
      }

      .primary-controls .load-btn-cell label {
        display: none;
      }

      .advanced-filters-toggle {
        border-top: 1px solid var(--glass-border);
        margin-top: 4px;
        padding-top: 12px;
      }

      .advanced-filters .control-group-row {
        flex-direction: column;
      }

      .advanced-filters .control.wide {
        min-width: unset;
        width: 100%;
      }

      .advanced-filters .control.checkbox-grid {
        width: 100%;
      }

      /* Fix nested Top Signals pane inside analyst mode to prevent overflow */
      .analyst-section .grid-halves {
        margin-left: 0;
        margin-right: 0;
      }

      .analyst-section .claude-pane {
        padding: 10px;
        overflow: hidden;
      }
    }

    /* Gmail Token Refresh Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 24px;
      max-width: 520px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 700;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .modal-close:hover {
      color: var(--text);
    }

    .modal-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .modal-step {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .modal-step-label {
      font-size: 13px;
      color: var(--muted);
    }

    .modal-step-content {
      font-size: 14px;
    }

    .auth-url-box {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 12px;
      word-break: break-all;
      font-size: 12px;
      font-family: monospace;
      color: var(--accent);
      max-height: 80px;
      overflow-y: auto;
    }

    .auth-url-box a {
      color: var(--accent);
      text-decoration: none;
    }

    .auth-url-box a:hover {
      text-decoration: underline;
    }

    .modal-input {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 12px;
      color: var(--text);
      font-size: 13px;
      font-family: var(--font);
      width: 100%;
      resize: vertical;
      min-height: 60px;
    }

    .modal-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }

    .modal-status {
      font-size: 13px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }

    .modal-status.visible {
      display: block;
    }

    .modal-status.success {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .modal-status.error {
      background: rgba(239, 68, 68, 0.15);
      color: var(--danger);
    }

    .modal-status.info {
      background: rgba(65, 214, 255, 0.15);
      color: var(--accent);
    }

    .card-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--glass-border);
    }

    .btn.fix-gmail {
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid var(--danger);
      color: var(--danger);
      font-size: 11px;
      padding: 5px 12px;
    }

    .btn.fix-gmail:hover {
      background: rgba(239, 68, 68, 0.25);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Local LLM Mail Screener</h1>

    <div class="health-row" id="health-cards"></div>

    <div class="card stats-section">
      <div class="card-header">
        <span class="card-title">Token & Activity</span>
        <span class="config-info" id="config"></span>
      </div>
      <div class="stats-grid" id="stats-grid"></div>
    </div>

    <!-- GPU Utilization Panel (hidden if data unavailable) -->
    <div class="card gpu-section" id="gpu-section" style="display:none;">
      <div class="card-header">
        <div class="gpu-header-left">
          <span class="card-title">GPU Utilization</span>
          <span class="gpu-name" id="gpu-name"></span>
        </div>
        <div class="gpu-current-stats" id="gpu-current-stats"></div>
      </div>
      <div class="gpu-chart-container">
        <div class="gpu-chart-wrapper">
          <canvas id="gpu-chart"></canvas>
          <div class="gpu-x-axis" id="gpu-x-axis"></div>
        </div>
        <div class="gpu-legend" id="gpu-legend"></div>
      </div>
    </div>

    <div class="card notifications-section" id="notifications-section">
      <div class="card-header clickable" id="notifications-header">
        <span class="card-title">Recent Notifications</span>
        <button class="collapse-toggle" id="notifications-toggle" title="Collapse/Expand">▼</button>
        <span class="card-meta">Latest first · max 50</span>
      </div>
      <div class="notifications-grid" id="notifications-grid"></div>
    </div>

    <div class="card analyst-section collapsed" id="analyst-section">
      <div class="card-header clickable" id="analyst-header">
        <div class="analyst-header-left">
          <div class="analyst-header-title">
            <span class="card-title">Analyst Mode</span>
            <button class="collapse-toggle" id="analyst-toggle" title="Collapse/Expand">▼</button>
          </div>
          <span class="card-meta">Manual refusal exploration and Claude analysis</span>
        </div>
      </div>
      <div class="analyst-panel-content" id="analyst-panel">
        <div class="analyst-panel-subheader">
          <span class="analyst-meta" id="analyst-title">Filtered 0 refusals</span>
          <div class="pill-outline" id="analyst-window-label"></div>
        </div>

      <div class="analyst-controls">
        <!-- Primary controls: 2x3 grid on mobile -->
        <div class="primary-controls">
          <div class="control">
            <label>From (hours)</label>
            <div class="control-row">
              <button class="btn secondary small" data-step-start-hours="-1">−</button>
              <input type="number" id="start-hours-input" min="0" max="336" value="0" />
              <button class="btn secondary small" data-step-start-hours="1">+</button>
            </div>
          </div>
          <div class="control">
            <label>From (days)</label>
            <div class="control-row">
              <button class="btn secondary small" data-step-start-days="-1">−</button>
              <input type="number" id="start-days-input" min="0" max="30" value="1" />
              <button class="btn secondary small" data-step-start-days="1">+</button>
            </div>
          </div>
          <div class="control">
            <label>To (hours)</label>
            <div class="control-row">
              <button class="btn secondary small" data-step-end-hours="-1">−</button>
              <input type="number" id="end-hours-input" min="0" max="336" value="0" />
              <button class="btn secondary small" data-step-end-hours="1">+</button>
            </div>
          </div>
          <div class="control">
            <label>To (days)</label>
            <div class="control-row">
              <button class="btn secondary small" data-step-end-days="-1">−</button>
              <input type="number" id="end-days-input" min="0" max="30" value="0" />
              <button class="btn secondary small" data-step-end-days="1">+</button>
            </div>
          </div>
          <div class="control">
            <label id="model-label">Model</label>
            <select id="model-select">
              <option value="opus">Opus</option>
              <option value="sonnet">Sonnet</option>
              <option value="gemini">Gemini</option>
            </select>
          </div>
          <div class="control load-btn-cell">
            <label>&nbsp;</label>
            <button class="btn" id="load-analytics">Load refusals</button>
          </div>
        </div>

        <!-- Advanced filters toggle -->
        <div class="advanced-filters-toggle collapsed" id="advanced-filters-toggle">
          <span>Advanced Filters</span>
          <button class="collapse-toggle" title="Collapse/Expand">▼</button>
        </div>

        <!-- Advanced filters (collapsed by default on mobile) -->
        <div class="advanced-filters collapsed" id="advanced-filters">
          <div class="control-group-row">
            <div class="control checkbox-grid">
              <div class="checkbox-2x2">
                <label><input type="checkbox" id="has-attachments" /> Attachments</label>
                <label><input type="checkbox" id="has-ip-urls" /> IP URLs</label>
                <label><input type="checkbox" id="has-urls" /> URLs</label>
                <label><input type="checkbox" id="has-mismatch" /> Mismatched</label>
              </div>
            </div>
            <span class="analyst-meta" id="analyst-status"></span>
          </div>
          <div class="control-group-row">
            <div class="control wide">
              <label>Reason contains</label>
              <input id="reason-filter" placeholder="marketing, newsletter, etc" />
            </div>
            <div class="control wide">
              <label>Subject contains</label>
              <input id="subject-filter" placeholder="invoice, alert, etc" />
            </div>
            <div class="control wide">
              <label>From contains</label>
              <input id="from-filter" placeholder="example.com, sender" />
            </div>
            <div class="control wide">
              <label>Domain contains</label>
              <input id="domain-filter" placeholder="domain.com" />
            </div>
            <div class="control">
              <label>Confidence</label>
              <div class="control-row">
                <input id="min-conf" type="number" min="0" max="1" step="0.05" placeholder="min" style="width:55px;" />
                <input id="max-conf" type="number" min="0" max="1" step="0.05" placeholder="max" style="width:55px;" />
              </div>
            </div>
            <div class="control wide">
              <label>Removed sections</label>
              <input id="removed-section" placeholder="unsubscribe_footer, reply_hea..." />
            </div>
          </div>
        </div>
      </div>

      <!-- Claude Output (always visible header, content hidden until run) -->
      <div class="claude-output-section section-spacer">
        <div class="claude-pane-header">
          <div class="claude-pane-title">
            <span class="card-title">Claude Output</span>
            <span class="pill-outline" id="claude-meta"></span>
          </div>
          <div class="claude-pane-actions">
            <button class="btn" id="run-claude">Run analysis</button>
            <div class="segment-toggle" id="view-toggle">
              <button id="view-rendered-btn" class="active">Rendered</button>
              <button id="view-raw-btn">Raw</button>
            </div>
            <button class="btn secondary small" id="copy-output" disabled>Copy</button>
          </div>
        </div>
        <div class="claude-output-content" id="claude-output-content" style="display:none;">
          <div class="rendered" id="claude-output-rendered"></div>
          <pre class="mono" id="claude-output-raw" style="display:none;"></pre>
        </div>
      </div>

      <div class="card charts-card" id="charts-card">
        <div class="chart-select-row">
          <span class="card-title">Charts</span>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <select id="chart-select">
              <option value="none">None</option>
              <option value="confidence-hist">Confidence distribution</option>
              <option value="confidence-reason">Confidence by reason</option>
              <option value="time-heat">Time heatmap (hour x weekday)</option>
              <option value="reason-trend">Reason trend over time</option>
              <option value="domain-bars">Sender/domain concentration</option>
              <option value="risk-mix">URL/Attachment mix</option>
              <option value="removed-sections">Removed sections impact</option>
            </select>
            <button class="btn secondary small" id="run-reason-buckets">Bucket reasons with Gemini</button>
            <span class="analyst-meta" id="reason-buckets-status"></span>
            <button class="btn secondary small" id="chart-back" disabled>Back</button>
            <span class="chart-range-label" id="chart-range-label"></span>
          </div>
        </div>
        <div class="chart-area" id="chart-area">
          <canvas id="refusal-chart" height="260"></canvas>
        </div>
      </div>

      <!-- Results Grid -->
      <div class="grid-halves section-spacer">
        <div class="claude-pane signals-pane">
          <div class="card-title">Top Signals</div>
          <div id="top-signals"></div>
          <div class="signal-label" style="margin-top:12px;">Hourly Distribution</div>
          <div class="list-scroll wrap" id="bucket-list"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card notifications-section collapsed" id="refusals-section">
    <div class="card-header clickable" id="refusals-header">
      <span class="card-title">Latest Refusals</span>
      <button class="collapse-toggle" id="refusals-toggle" title="Collapse/Expand">▼</button>
      <span class="card-meta">From analyst filters</span>
    </div>
    <div class="notifications-grid" id="latest-refusals"></div>
  </div>

  <!-- Gmail Token Refresh Modal -->
  <div class="modal-overlay" id="gmail-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">Refresh Gmail Token</span>
        <button class="modal-close" id="gmail-modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="modal-step">
          <span class="modal-step-label">Step 1: Click the link below to authorize Gmail access</span>
          <div class="auth-url-box" id="gmail-auth-url">Loading...</div>
        </div>
        <div class="modal-step">
          <span class="modal-step-label">Step 2: After authorizing, you'll be redirected to localhost (it may show an error). Copy the full URL from your browser's address bar and paste it below:</span>
          <textarea class="modal-input" id="gmail-code-input" placeholder="Paste the redirect URL or authorization code here..."></textarea>
        </div>
        <div class="modal-status" id="gmail-modal-status"></div>
        <div class="modal-actions">
          <button class="btn" id="gmail-submit-code">Submit &amp; Validate</button>
          <button class="btn secondary" id="gmail-modal-cancel">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { computeGpuChartColumns, GPU_CHART_CONSTANTS } from './gpu_chart_math.js';
    const healthCards = document.getElementById('health-cards');
    const statsGrid = document.getElementById('stats-grid');
    const notificationsGrid = document.getElementById('notifications-grid');
    const notificationsSection = document.getElementById('notifications-section');
    const notificationsHeader = document.getElementById('notifications-header');
    const notificationsToggle = document.getElementById('notifications-toggle');
    const refusalsSection = document.getElementById('refusals-section');
    const refusalsHeader = document.getElementById('refusals-header');
    const configEl = document.getElementById('config');
    const gpuSection = document.getElementById('gpu-section');
    const gpuNameEl = document.getElementById('gpu-name');
    const gpuCurrentStats = document.getElementById('gpu-current-stats');
    const gpuChartCanvas = document.getElementById('gpu-chart');
    const gpuXAxis = document.getElementById('gpu-x-axis');
    const gpuLegend = document.getElementById('gpu-legend');
    const analystSection = document.getElementById('analyst-section');
    const analystHeader = document.getElementById('analyst-header');
    const analystToggle = document.getElementById('analyst-toggle');
    const analystPanel = document.getElementById('analyst-panel');
    const advancedFiltersToggle = document.getElementById('advanced-filters-toggle');
    const advancedFilters = document.getElementById('advanced-filters');
    const analystStatus = document.getElementById('analyst-status');
    const analystTitle = document.getElementById('analyst-title');
    const analystWindowLabel = document.getElementById('analyst-window-label');
    const bucketList = document.getElementById('bucket-list');
    const latestRefusals = document.getElementById('latest-refusals');
    const topSignals = document.getElementById('top-signals');
    const signalsPane = document.querySelector('.signals-pane');
    const claudeMeta = document.getElementById('claude-meta');
    const claudeOutputRendered = document.getElementById('claude-output-rendered');
    const claudeOutputRaw = document.getElementById('claude-output-raw');
    const viewRenderedBtn = document.getElementById('view-rendered-btn');
    const viewRawBtn = document.getElementById('view-raw-btn');
    const copyOutputBtn = document.getElementById('copy-output');
    const chartSelect = document.getElementById('chart-select');
    const chartArea = document.getElementById('chart-area');
    const chartsCard = document.getElementById('charts-card');
    const chartCanvas = document.getElementById('refusal-chart');
    const reasonBucketsBtn = document.getElementById('run-reason-buckets');
    const reasonBucketsStatus = document.getElementById('reason-buckets-status');
    const chartBackBtn = document.getElementById('chart-back');
    const chartRangeLabel = document.getElementById('chart-range-label');
    const modelLabel = document.getElementById('model-label');
    const startHoursInput = document.getElementById('start-hours-input');
    const startDaysInput = document.getElementById('start-days-input');
    const endHoursInput = document.getElementById('end-hours-input');
    const endDaysInput = document.getElementById('end-days-input');
    const gmailModal = document.getElementById('gmail-modal');
    const gmailAuthUrl = document.getElementById('gmail-auth-url');
    const gmailCodeInput = document.getElementById('gmail-code-input');
    const gmailModalStatus = document.getElementById('gmail-modal-status');
    const gmailSubmitCode = document.getElementById('gmail-submit-code');
    const gmailModalClose = document.getElementById('gmail-modal-close');
    const gmailModalCancel = document.getElementById('gmail-modal-cancel');
    const reasonFilter = document.getElementById('reason-filter');
    const subjectFilter = document.getElementById('subject-filter');
    const fromFilter = document.getElementById('from-filter');
    const domainFilter = document.getElementById('domain-filter');
    const minConf = document.getElementById('min-conf');
    const maxConf = document.getElementById('max-conf');
    const hasAttachments = document.getElementById('has-attachments');
    const hasUrls = document.getElementById('has-urls');
    const hasIpUrls = document.getElementById('has-ip-urls');
    const hasMismatch = document.getElementById('has-mismatch');
    const removedSection = document.getElementById('removed-section');
    const modelSelect = document.getElementById('model-select');
    const loadAnalyticsBtn = document.getElementById('load-analytics');
    const runClaudeBtn = document.getElementById('run-claude');
    const claudeOutputContent = document.getElementById('claude-output-content');

    const fmtTime = (ts) => ts ? new Date(ts).toLocaleString() : '—';
    
    const fmtTimeShort = (ts) => {
      if (!ts) return '—';
      const d = new Date(ts);
      return d.toLocaleString(undefined, { 
        month: 'short', day: 'numeric', 
        hour: 'numeric', minute: '2-digit' 
      });
    };

    const fmtNum = (n) => {
      if (n == null || isNaN(n)) return '0';
      const abs = Math.abs(n);
      if (abs >= 1e12) return (n / 1e12).toFixed(abs >= 1e13 ? 0 : 2).replace(/\.?0+$/, '') + 'T';
      if (abs >= 1e9) return (n / 1e9).toFixed(abs >= 1e10 ? 1 : 2).replace(/\.?0+$/, '') + 'B';
      if (abs >= 1e6) return (n / 1e6).toFixed(abs >= 1e7 ? 1 : 2).replace(/\.?0+$/, '') + 'M';
      if (abs >= 1e5) return (n / 1e3).toFixed(0) + 'K';
      if (abs >= 1e4) return (n / 1e3).toFixed(1).replace(/\.0$/, '') + 'K';
      if (abs >= 1e3) return (n / 1e3).toFixed(2).replace(/\.?0+$/, '') + 'K';
      return String(n);
    };

    const fmtComma = (n) => (n || 0).toLocaleString();
    const escapeHtml = (str = '') => String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');

    const renderMarkdown = (text) => {
      if (window.marked?.parse) {
        return window.marked.parse(text || '');
      }
      // Fallback: basic newline + bold/italic
      let html = escapeHtml(text || '');
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
      html = html.replace(/\n/g, '<br/>');
      return html;
    };

    const clearChart = () => {
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    };

    const renderChart = (type, data) => {
      clearChart();
      if (!chartCanvas || !data || !data.samples || !data.samples.length || type === 'none') {
        if (chartArea) chartArea.classList.remove('active');
        chartDrillStack = [];
        if (chartBackBtn) chartBackBtn.disabled = true;
        if (chartRangeLabel) chartRangeLabel.textContent = '';
        return;
      }
      if (chartArea) chartArea.classList.add('active');
      const ctx = chartCanvas.getContext('2d');

      const baseSamples = data.samples || [];
      const activeRange = chartDrillStack.length
        ? chartDrillStack[chartDrillStack.length - 1]
        : { min: 0, max: 1 };
      const samples = baseSamples.filter((s) => {
        const c = s.confidence ?? 0;
        return c >= activeRange.min && c <= activeRange.max + 1e-9;
      });
      if (chartBackBtn) chartBackBtn.disabled = chartDrillStack.length === 0;
      if (chartRangeLabel) {
        chartRangeLabel.textContent =
          chartDrillStack.length === 0
            ? 'Range: 0.00 - 1.00'
            : `Range: ${activeRange.min.toFixed(2)} - ${activeRange.max.toFixed(2)}`;
      }
      const reasonBuckets = data.reasonBuckets || [];
      const reasonAssignments = data.reasonAssignments || [];
      const idToSample = new Map();
      samples.forEach((s) => {
        if (s.id) idToSample.set(s.id, s);
      });
      const toDomain = (email = '') => {
        const m = String(email).toLowerCase().match(/@([^>]+)>?$/);
        if (m && m[1]) return m[1];
        const parts = String(email).split('@');
        return parts[1] ? parts[1].toLowerCase() : '';
      };

      const commonOpts = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#e8ecf5' } },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          x: { ticks: { color: '#e8ecf5' }, grid: { color: 'rgba(255,255,255,0.05)' } },
          y: { ticks: { color: '#e8ecf5' }, grid: { color: 'rgba(255,255,255,0.05)' } }
        }
      };

      if (type === 'confidence-hist') {
        const rangeWidth = Math.max(0.0001, activeRange.max - activeRange.min);
        const canDrillFurther = rangeWidth > MIN_BIN_WIDTH + 1e-9;

        const buildBins = () => {
          if (!canDrillFurther) return [{ min: activeRange.min, max: activeRange.max }];
          if (rangeWidth <= MIN_BIN_WIDTH * 5 + 1e-9) {
            const bins = [];
            let cursor = activeRange.min;
            while (cursor < activeRange.max - 1e-9) {
              const next = Math.min(activeRange.max, Number((cursor + MIN_BIN_WIDTH).toFixed(4)));
              bins.push({ min: cursor, max: next });
              cursor = next;
            }
            return bins.length ? bins : [{ min: activeRange.min, max: activeRange.max }];
          }
          const binCount = 5;
          const step = rangeWidth / binCount;
          return Array.from({ length: binCount }, (_, i) => ({
            min: activeRange.min + step * i,
            max: i === binCount - 1 ? activeRange.max : activeRange.min + step * (i + 1)
          }));
        };

        const binRanges = buildBins();
        const counts = binRanges.map((r, idx) => {
          const isLast = idx === binRanges.length - 1;
          return samples.filter((s) => {
            const c = s.confidence ?? 0;
            return c >= r.min && (isLast ? c <= r.max + 1e-9 : c < r.max);
          }).length;
        });
        if (!counts.some((c) => c > 0)) {
          if (chartBackBtn) chartBackBtn.disabled = chartDrillStack.length === 0;
          return;
        }
        const labels = binRanges.map((r, idx) => {
          const isLast = idx === binRanges.length - 1;
          const start = r.min.toFixed(2);
          const end = r.max.toFixed(2);
          return `${isLast ? '[' : '['}${start}, ${end}${isLast ? ']' : ')'}`;
        });

        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{ label: 'Refusals', data: counts, backgroundColor: '#41d6ff88', borderColor: '#41d6ff' }]
          },
          options: {
            ...commonOpts,
            plugins: { ...commonOpts.plugins, legend: { display: false } },
            onClick: (_evt, elements) => {
              if (!elements || !elements.length) return;
              if (!canDrillFurther) return;
              const idx = elements[0].index;
              const selected = binRanges[idx];
              if (!selected) return;
              // Stop if bin width would be <= MIN_BIN_WIDTH
              if (selected.max - selected.min <= MIN_BIN_WIDTH + 1e-9) return;
              chartDrillStack.push(selected);
              renderChart(type, data);
            }
          }
        });
        return;
      }

      if (type === 'confidence-reason') {
        const useClaude = reasonBuckets.length && reasonAssignments.length;
        const reasonMap = new Map();
        if (useClaude) {
          reasonAssignments.forEach((a) => {
            const key = a.bucket || 'Other';
            const conf = a.confidence ?? idToSample.get(a.id)?.confidence ?? 0;
            if (!reasonMap.has(key)) reasonMap.set(key, []);
            reasonMap.get(key).push(conf);
          });
        } else {
          samples.forEach((s) => {
            const key = (s.reason || 'Unknown').slice(0, 60);
            if (!reasonMap.has(key)) reasonMap.set(key, []);
            reasonMap.get(key).push(s.confidence ?? 0);
          });
        }
        const arr = Array.from(reasonMap.entries()).map(([label, vals]) => ({
          label,
          avg: vals.reduce((a, b) => a + b, 0) / vals.length,
          count: vals.length
        })).sort((a, b) => b.count - a.count).slice(0, useClaude ? 12 : 7);
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: arr.map((r) => r.label),
            datasets: [{ label: 'Avg confidence', data: arr.map((r) => r.avg), backgroundColor: '#c084f588', borderColor: '#c084f5' }]
          },
          options: commonOpts
        });
        return;
      }

      if (type === 'time-heat') {
        const grid = Array.from({ length: 7 }, () => Array(24).fill(0));
        samples.forEach((s) => {
          const ts = s.decided_at || 0;
          if (!ts) return;
          const d = new Date(ts);
          const dow = d.getDay(); // 0 sun
          const hr = d.getHours();
          grid[dow][hr] += 1;
        });
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
            datasets: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, idx) => ({
              label: day,
              data: grid[idx],
              stack: 'time',
              backgroundColor: `hsla(${idx * 45},70%,60%,0.5)`
            }))
          },
          options: { ...commonOpts, scales: { ...commonOpts.scales, x: { stacked: true, ticks: { color: '#e8ecf5' }, grid: { color: 'rgba(255,255,255,0.05)' } }, y: { stacked: true, ticks: { color: '#e8ecf5' } } } }
        });
        return;
      }

      if (type === 'reason-trend') {
        const useClaude = reasonBuckets.length && reasonAssignments.length;
        const topReasons = useClaude
          ? reasonBuckets.map((b) => b.name)
          : (data.top_reasons || []).slice(0, 5).map((r) => r.label);
        const buckets = new Map();
        const addPoint = (id, reasonLabel) => {
          const sample = idToSample.get(id);
          const ts = sample?.decided_at || 0;
          if (!ts) return;
          const d = new Date(ts);
          const label = `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(d.getUTCDate()).padStart(2, '0')} ${String(d.getUTCHours()).padStart(2, '0')}:00`;
          if (!buckets.has(label)) buckets.set(label, {});
          const bucket = buckets.get(label);
          if (topReasons.includes(reasonLabel)) {
            bucket[reasonLabel] = (bucket[reasonLabel] || 0) + 1;
          }
        };

        if (useClaude) {
          reasonAssignments.forEach((a) => addPoint(a.id, a.bucket));
        } else {
          samples.forEach((s) => addPoint(s.id, (s.reason || '').slice(0, 60)));
        }

        const labels = Array.from(buckets.keys()).sort();
        const datasets = topReasons.map((r, idx) => ({
          label: r,
          data: labels.map((l) => buckets.get(l)?.[r] || 0),
          borderColor: `hsl(${idx * 40 + 20}, 75%, 60%)`,
          backgroundColor: `hsla(${idx * 40 + 20}, 75%, 60%, 0.2)`,
          fill: true,
          tension: 0.2
        }));
        chartInstance = new Chart(ctx, {
          type: 'line',
          data: { labels, datasets },
          options: commonOpts
        });
        return;
      }

      if (type === 'domain-bars') {
        const counts = new Map();
        samples.forEach((s) => {
          const d = toDomain(s.from);
          if (!d) return;
          counts.set(d, (counts.get(d) || 0) + 1);
        });
        const arr = Array.from(counts.entries()).map(([label, count]) => ({ label, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 10);
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: arr.map((r) => r.label),
            datasets: [{ label: 'Refusals', data: arr.map((r) => r.count), backgroundColor: '#41d6ff88', borderColor: '#41d6ff' }]
          },
          options: { ...commonOpts, indexAxis: 'y' }
        });
        return;
      }

      if (type === 'risk-mix') {
        const flags = { attachments: 0, urls: 0, ip_urls: 0, mismatch: 0 };
        samples.forEach((s) => {
          const f = s.feature_flags || {};
          flags.attachments += f.has_attachments ? 1 : 0;
          flags.urls += f.has_urls ? 1 : 0;
          flags.ip_urls += f.has_ip_based_urls ? 1 : 0;
          flags.mismatch += f.has_mismatched_urls ? 1 : 0;
        });
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Attachments', 'URLs', 'IP URLs', 'Mismatched URLs'],
            datasets: [{ label: 'Counts', data: [flags.attachments, flags.urls, flags.ip_urls, flags.mismatch], backgroundColor: '#22c55e88', borderColor: '#22c55e' }]
          },
          options: { ...commonOpts, plugins: { ...commonOpts.plugins, legend: { display: false } } }
        });
        return;
      }

      if (type === 'removed-sections') {
        const counts = new Map();
        samples.forEach((s) => {
          const sections = s.removed_sections || [];
          sections.forEach((sec) => {
            const key = String(sec);
            counts.set(key, (counts.get(key) || 0) + 1);
          });
        });
        const arr = Array.from(counts.entries()).map(([label, count]) => ({ label, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 10);
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: arr.map((r) => r.label),
            datasets: [{ label: 'Removed count', data: arr.map((r) => r.count), backgroundColor: '#f59e0b88', borderColor: '#f59e0b' }]
          },
          options: commonOpts
        });
        return;
      }

      // Fallback: hide chart
      ensureChartVisible(false);
    };
    const applyViewToggle = () => {
      const view = analystState.view;
      const showRendered = view === 'rendered';
      claudeOutputRendered.style.display = showRendered ? 'block' : 'none';
      claudeOutputRaw.style.display = showRendered ? 'none' : 'block';
      viewRenderedBtn.classList.toggle('active', showRendered);
      viewRawBtn.classList.toggle('active', !showRendered);
    };

    const statusBadge = (ok) => {
      const cls = ok ? 'ok' : 'fail';
      const label = ok ? 'OK' : 'FAIL';
      return `<span class="status ${cls}">${label}</span>`;
    };

    const urgencyPill = (u) => {
      const level = u || 'normal';
      return `<span class="pill ${level}">${level}</span>`;
    };

    const renderHealth = (health, cfg = {}) => {
      const items = [
        { key: 'gmail', label: 'Gmail' },
        { key: 'llm', label: 'LLM' }
      ];
      if (health.notification) {
        const svc = health.notification.service || 'notification';
        items.push({ key: 'notification', label: `Notification (${svc})` });
      }

      healthCards.innerHTML = items.map((item) => {
        const h = health[item.key] || {};
        const ok = !!h.ok;
        const errorLine = h.last_error
          ? `<div class="card-meta" style="margin-top:6px;color:var(--danger);">Error: ${h.last_error}</div>`
          : '';
        const latencyLine = item.key === 'llm' && h.avg_latency_ms
          ? `<div class="card-meta">Avg latency: ${h.avg_latency_ms} ms</div>`
          : '';
        const modelLine =
          item.key === 'llm' && cfg.llm_model
            ? `<div class="card-meta">Model: ${cfg.llm_model}</div>`
            : '';
        // Show "Fix Gmail" button in footer when Gmail is failing
        const fixGmailFooter = item.key === 'gmail' && !ok
          ? `<div class="card-footer"><button class="btn fix-gmail" id="fix-gmail-btn">Fix Gmail Token</button></div>`
          : '';

        return `
          <div class="card">
            <div class="card-header">
              <span class="card-title">${item.label}</span>
              ${statusBadge(ok)}
            </div>
            <div class="card-meta">Last success: ${fmtTime(h.last_success_at)}</div>
            ${latencyLine}
            ${modelLine}
            ${errorLine}
            ${fixGmailFooter}
          </div>
        `;
      }).join('');

      // Attach click handler to Fix Gmail button if it exists
      const fixBtn = document.getElementById('fix-gmail-btn');
      if (fixBtn) {
        fixBtn.addEventListener('click', openGmailModal);
      }
    };

    const renderStats = (stats) => {
      const queue = stats.llm_queue || {};
      const tps = stats.llm_tps || {};
      const items = [
        { label: 'Total Tokens', value: fmtNum(stats.tokens_total_est || 0) },
        { label: 'Tokens 24h', value: fmtNum(stats.last_24h_tokens_est || 0) },
        { label: 'Emails', value: fmtComma(stats.emails_processed) },
        { label: 'Notifications', value: stats.notifications_sent || 0 },
        { label: 'LLM Requests', value: stats.llm_requests || 0 },
        { label: 'Queue', value: `${queue.depth || 0}/${queue.max_queue || 0}` },
        { label: 'Dropped', value: queue.dropped_total || 0 },
        { label: 'TPS (avg 5)', value: tps.avg_tps || 0 }
      ];

      statsGrid.innerHTML = items.map(i => `
        <div class="stat">
          <div class="stat-label">${i.label}</div>
          <div class="stat-value">${i.value}</div>
        </div>
      `).join('');
    };

    const renderNotifications = (sends) => {
      if (!sends || sends.length === 0) {
        notificationsGrid.innerHTML = '<div class="empty-state">No notifications yet</div>';
        return;
      }

      notificationsGrid.innerHTML = sends.map((s) => {
        const urgency = s.urgency || 'normal';
        const notifId = s.notification_id || s.twilio_sid || s.pushover_receipt || '—';
        const reason = (s.sms_preview || '').replace(/</g, '&lt;');
        const gmailLink = s.gmail_link 
          ? `<a href="${s.gmail_link}" target="_blank" class="notif-link">Open in Gmail</a>` 
          : '';

        return `
          <div class="notification-card ${urgency}">
            <div class="notif-row">
              <span><span class="notif-label">From:</span>${s.from || '—'}</span>
              <span><span class="notif-label">Sent:</span>${fmtTimeShort(s.sent_at)}</span>
            </div>
            <div class="notif-row">
              <span><span class="notif-label">Via:</span>${(s.notification_provider || '').toUpperCase() || '—'}</span>
              <span><span class="notif-label">Tokens:</span>${s.tokens_for_email || 0}</span>
            </div>
            <div class="notif-field subject">
              <span class="notif-label">Subject:</span>
              <span class="notif-value">${s.subject || 'No subject'}</span>
            </div>
            <div class="notif-field reason">
              <span class="notif-label">Reason:</span>
              <span class="notif-value">${reason}</span>
            </div>
            <div class="notif-footer">
              <span class="notif-id">${notifId}</span>
              ${gmailLink}
            </div>
          </div>
        `;
      }).join('');
    };

    const renderConfig = (cfg) => {
      const svc = cfg.notification_service || 'twilio';
      configEl.textContent = `Poll ${cfg.poll_interval_ms}ms · Conc ${cfg.max_llm_concurrency} · Queue ${cfg.max_llm_queue} · Dry ${cfg.dry_run} · ${svc}`;
    };

    const renderGpu = (gpuData) => {
      if (!gpuData || !gpuData.enabled) {
        gpuSection.style.display = 'none';
        return;
      }

      gpuSection.style.display = 'block';
      gpuNameEl.textContent = gpuData.gpu_name || 'GPU';

      // Current stats
      const current = gpuData.current || {};
      const util = current.gpu_utilization;
      const hasUtil = util !== null && util !== undefined;
      const utilClass = hasUtil ? (util >= 80 ? 'high' : util >= 50 ? 'warn' : '') : '';
      const utilDisplay = hasUtil ? `${util.toFixed(1)}%` : '—';

      gpuCurrentStats.innerHTML = `
        <div class="gpu-stat">
          <span class="gpu-stat-label">GPU</span>
          <span class="gpu-stat-value ${utilClass}">${utilDisplay}</span>
        </div>
        <div class="gpu-stat">
          <span class="gpu-stat-label">Memory</span>
          <span class="gpu-stat-value">${current.memory_display || '—'}</span>
        </div>
      `;

      // Render chart
      renderGpuChart(gpuData);
    };

    const renderGpuChart = (gpuData) => {
      const history = gpuData.history || [];
      const currentBlock = gpuData.current_block || {};
      const blockDurationMs = gpuData.block_duration_ms || 15000;

      // Get canvas context and dimensions
      const ctx = gpuChartCanvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = gpuChartCanvas.getBoundingClientRect();

      // Set canvas size accounting for device pixel ratio
      gpuChartCanvas.width = rect.width * dpr;
      gpuChartCanvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Clear canvas
      ctx.clearRect(0, 0, rect.width, rect.height);

      const chart = computeGpuChartColumns({
        width: rect.width,
        height: rect.height,
        history,
        currentBlock,
        blockDurationMs,
        nowMs: Date.now()
      });

      const { LEVELS, GAP, WINDOW_MS } = GPU_CHART_CONSTANTS;
      const STEP_PCT = 100 / LEVELS; // ~6.67% per level
      const now = chart.nowMs;

      // Draw perfect squares - column 0 = newest = rightmost
      chart.aggregated.forEach(({ column, peak, inProgress, x }) => {

        // Number of squares to fill (minimum 1 to show "idle")
        const filledLevels = Math.max(1, Math.round(peak / STEP_PCT));

        // Color based on number of filled blocks (1-8: blue, 9-13: orange, 14-15: red)
        let color;
        if (filledLevels >= 13) {
          color = 'rgba(239, 68, 68, 0.9)';
        } else if (filledLevels >= 9) {
          color = 'rgba(245, 158, 11, 0.9)';
        } else {
          color = 'rgba(65, 214, 255, 0.9)';
        }

        ctx.fillStyle = color;

        // Draw perfect squares from bottom up
        for (let level = 0; level < filledLevels; level++) {
          const y = chart.offsetY + chart.actualHeight - (level + 1) * (chart.squareSize + GAP) + GAP;
          ctx.fillRect(x, y, chart.squareSize, chart.squareSize);
        }
      });

      // Update X-axis labels (10-minute increments)
      const xLabels = [];
      for (let i = 0; i <= 6; i++) {
        const timeAgo = i * 10 * 60 * 1000;
        const labelTime = new Date(now - WINDOW_MS + timeAgo);
        xLabels.push(labelTime.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', hour12: false }));
      }
      gpuXAxis.innerHTML = xLabels.map(l => `<span>${l}</span>`).join('');

      // Update legend with time per block
      const timePerColumnMs = chart.timePerColumn;
      const totalSeconds = Math.round(timePerColumnMs / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      let timeLabel;
      if (minutes > 0 && seconds > 0) {
        timeLabel = `${minutes} minute${minutes !== 1 ? 's' : ''} and ${seconds} second${seconds !== 1 ? 's' : ''}`;
      } else if (minutes > 0) {
        timeLabel = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
      } else {
        timeLabel = `${seconds} second${seconds !== 1 ? 's' : ''}`;
      }
      gpuLegend.innerHTML = `<span class="gpu-legend-block"></span> = peak GPU utilization over ${timeLabel}`;
    };

const analystState = { enabled: false, view: 'rendered', cfg: {}, refusalsLoaded: false };
    let chartInstance = null;
    let chartDataCache = null;
    let chartDrillStack = [];
    const MIN_BIN_WIDTH = 0.01;

    const updateWindowLabel = () => {
      const startHoursRaw = Number(startHoursInput.value);
      const startDaysRaw = Number(startDaysInput.value);
      const endHoursRaw = Number(endHoursInput.value);
      const endDaysRaw = Number(endDaysInput.value);
      const startHours = Number.isFinite(startHoursRaw) ? startHoursRaw : 0;
      const startDays = Number.isFinite(startDaysRaw) ? startDaysRaw : 0;
      const endHours = Number.isFinite(endHoursRaw) ? endHoursRaw : 0;
      const endDays = Number.isFinite(endDaysRaw) ? endDaysRaw : 0;
      const fromTotal = Math.max(1, startHours + startDays * 24);
      const toTotal = endHours + endDays * 24;
      if (toTotal === 0) {
        analystWindowLabel.textContent = `Last ${fromTotal}h`;
      } else {
        analystWindowLabel.textContent = `${fromTotal}h → ${toTotal}h ago`;
      }
    };

    const updateModelMaxLabel = () => {
      const model = modelSelect.value;
      const opusMax = analystState.cfg.analyst_max_items_opus || 150;
      const sonnetMax = analystState.cfg.analyst_max_items_sonnet || 150;
      const geminiMax = analystState.cfg.analyst_max_items_gemini || 500;
      let max;
      if (model === 'opus') max = opusMax;
      else if (model === 'gemini') max = geminiMax;
      else max = sonnetMax;
      if (modelLabel) modelLabel.textContent = `Model (${max} max)`;
      return max;
    };

    const buildFilterParams = () => {
      const params = new URLSearchParams();
      const startHoursRaw = Number(startHoursInput.value);
      const startDaysRaw = Number(startDaysInput.value);
      const endHoursRaw = Number(endHoursInput.value);
      const endDaysRaw = Number(endDaysInput.value);
      const startHoursVal = Number.isFinite(startHoursRaw) ? Math.max(0, Math.min(startHoursRaw, 24 * 60)) : 0;
      const startDaysVal = Number.isFinite(startDaysRaw) ? Math.max(0, Math.min(startDaysRaw, 60)) : 0;
      const endHoursVal = Number.isFinite(endHoursRaw) ? Math.max(0, Math.min(endHoursRaw, 24 * 60)) : 0;
      const endDaysVal = Number.isFinite(endDaysRaw) ? Math.max(0, Math.min(endDaysRaw, 60)) : 0;
      // Ensure at least 1 hour total for start (the older boundary)
      const startTotal = Math.max(1, startHoursVal + startDaysVal * 24);
      const endTotal = endHoursVal + endDaysVal * 24;
      params.set('start_hours', startTotal);
      params.set('end_hours', endTotal);
      if (reasonFilter.value) params.set('reason_includes', reasonFilter.value);
      if (subjectFilter.value) params.set('subject_includes', subjectFilter.value);
      if (fromFilter.value) params.set('from_includes', fromFilter.value);
      if (domainFilter.value) params.set('domain_includes', domainFilter.value);
      if (minConf.value) params.set('min_confidence', minConf.value);
      if (maxConf.value) params.set('max_confidence', maxConf.value);
      if (removedSection.value) params.set('removed_section', removedSection.value);
      if (hasAttachments.checked) params.set('has_attachments', 'true');
      if (hasUrls.checked) params.set('has_urls', 'true');
      if (hasIpUrls.checked) params.set('has_ip_based_urls', 'true');
      if (hasMismatch.checked) params.set('has_mismatched_urls', 'true');
      const limit = updateModelMaxLabel();
      params.set('limit', limit);
      return params;
    };

    const runReasonBucketing = async () => {
      const topSignalsBucketStatus = document.getElementById('top-signals-bucket-status');
      if (!chartDataCache || !chartDataCache.samples || !chartDataCache.samples.length) {
        if (reasonBucketsStatus) reasonBucketsStatus.textContent = 'Load refusals first';
        if (topSignalsBucketStatus) topSignalsBucketStatus.textContent = 'Load refusals first';
        return;
      }
      // Update status in both locations
      if (reasonBucketsStatus) reasonBucketsStatus.textContent = 'Bucketing...';
      if (topSignalsBucketStatus) topSignalsBucketStatus.textContent = 'Bucketing...';

      const startHoursRaw = Number(startHoursInput.value);
      const startDaysRaw = Number(startDaysInput.value);
      const endHoursRaw = Number(endHoursInput.value);
      const endDaysRaw = Number(endDaysInput.value);
      const startHoursVal = Number.isFinite(startHoursRaw) ? Math.max(0, Math.min(startHoursRaw, 24 * 60)) : 0;
      const startDaysVal = Number.isFinite(startDaysRaw) ? Math.max(0, Math.min(startDaysRaw, 60)) : 0;
      const endHoursVal = Number.isFinite(endHoursRaw) ? Math.max(0, Math.min(endHoursRaw, 24 * 60)) : 0;
      const endDaysVal = Number.isFinite(endDaysRaw) ? Math.max(0, Math.min(endDaysRaw, 60)) : 0;
      const filters = {};
      if (reasonFilter.value) filters.reason_includes = reasonFilter.value;
      if (subjectFilter.value) filters.subject_includes = subjectFilter.value;
      if (fromFilter.value) filters.from_includes = fromFilter.value;
      if (domainFilter.value) filters.domain_includes = domainFilter.value;
      if (minConf.value) filters.min_confidence = minConf.value;
      if (maxConf.value) filters.max_confidence = maxConf.value;
      if (removedSection.value) filters.removed_section = removedSection.value;
      if (hasAttachments.checked) filters.has_attachments = true;
      if (hasUrls.checked) filters.has_urls = true;
      if (hasIpUrls.checked) filters.has_ip_based_urls = true;
      if (hasMismatch.checked) filters.has_mismatched_urls = true;
      const limit = updateModelMaxLabel();
      const payload = {
        model: 'gemini',
        max_items: limit,
        start_hours: Math.max(1, startHoursVal + startDaysVal * 24),
        end_hours: endHoursVal + endDaysVal * 24,
        filters
      };
      try {
        const res = await fetch('/api/analysis/reasons', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok || data.ok === false) {
          const msg = data.error || 'Reason bucketing failed';
          if (reasonBucketsStatus) reasonBucketsStatus.textContent = msg;
          if (topSignalsBucketStatus) topSignalsBucketStatus.textContent = msg;
          return;
        }
        chartDataCache = {
          ...(chartDataCache || {}),
          reasonBuckets: data.buckets || [],
          reasonAssignments: data.assignments || []
        };
        const bucketCount = (data.buckets || []).length;
        if (reasonBucketsStatus) reasonBucketsStatus.textContent = `Buckets ready (${bucketCount})`;
        // Re-render top signals with bucket data
        renderTopSignals(chartDataCache, chartDataCache);
        // Re-render chart if active
        renderChart(chartSelect?.value || 'none', chartDataCache);
      } catch (err) {
        console.error('Reason bucketing failed', err);
        if (reasonBucketsStatus) reasonBucketsStatus.textContent = 'Reason bucketing failed';
        if (topSignalsBucketStatus) topSignalsBucketStatus.textContent = 'Bucketing failed';
      }
    };

    const renderBuckets = (buckets = []) => {
      if (!buckets.length) {
        bucketList.innerHTML = '<div class="analyst-meta">No refusals in range.</div>';
        return;
      }
      bucketList.innerHTML = buckets
        .map((b) => `<span class="signal-chip">${escapeHtml(b.label)}<span class="count">${b.count}</span></span>`)
        .join('');
    };

    // Track active bucket filter for Latest Refusals
    let activeBucketFilter = null;

    const renderTopSignals = (analytics, bucketData = {}) => {
      const renderSection = (arr, label) => {
        if (!arr || !arr.length) return '';
        const chips = arr.slice(0, 6).map((r) =>
          `<span class="signal-chip">${escapeHtml(r.label)}<span class="count">${r.count}</span></span>`
        ).join('');
        return `<div class="signal-section"><div class="signal-label">${label}</div><div class="signal-items">${chips}</div></div>`;
      };

      // Check if we have bucketed reasons
      const reasonBuckets = bucketData.reasonBuckets || [];
      const reasonAssignments = bucketData.reasonAssignments || [];
      const hasBuckets = reasonBuckets.length > 0 && reasonAssignments.length > 0;

      let reasonsSection = '';
      if (hasBuckets) {
        // Show ALL bucketed reasons with counts (clickable)
        const bucketCounts = new Map();
        reasonAssignments.forEach((a) => {
          const key = a.bucket || 'Other';
          bucketCounts.set(key, (bucketCounts.get(key) || 0) + 1);
        });
        const bucketArr = Array.from(bucketCounts.entries())
          .map(([label, count]) => ({ label, count }))
          .sort((a, b) => b.count - a.count);
        const chips = bucketArr.map((r) => {
          const isActive = activeBucketFilter === r.label;
          return `<span class="signal-chip clickable${isActive ? ' active' : ''}" data-bucket="${escapeHtml(r.label)}">${escapeHtml(r.label)}<span class="count">${r.count}</span></span>`;
        }).join('');
        reasonsSection = `<div class="signal-section"><div class="signal-label">Top Reasons</div><div class="signal-items">${chips}</div></div>`;
      } else {
        // Show button to bucket reasons
        reasonsSection = `<div class="signal-section"><div class="signal-label">Top Reasons</div><div class="signal-items"><button class="btn secondary small" id="top-signals-bucket-btn">Bucket reasons with Gemini</button><span class="analyst-meta" id="top-signals-bucket-status"></span></div></div>`;
      }

      const sections = [
        reasonsSection,
        renderSection(analytics.top_senders, 'Top Senders'),
        renderSection(analytics.top_domains, 'Top Domains')
      ].filter(Boolean);

      topSignals.innerHTML = sections.length ? sections.join('') : '<div class="analyst-meta">No signals found</div>';
      chartDataCache = { ...(chartDataCache || {}), ...analytics };

      // Attach click handler for the bucket button if it exists
      const topSignalsBucketBtn = document.getElementById('top-signals-bucket-btn');
      if (topSignalsBucketBtn) {
        topSignalsBucketBtn.addEventListener('click', runReasonBucketing);
      }

      // Attach click handlers for clickable bucket chips
      topSignals.querySelectorAll('.signal-chip.clickable').forEach((chip) => {
        chip.addEventListener('click', () => {
          const bucket = chip.dataset.bucket;
          if (activeBucketFilter === bucket) {
            // Toggle off - show all refusals
            activeBucketFilter = null;
            renderLatestRefusals(chartDataCache.latest || []);
          } else {
            // Filter to this bucket
            activeBucketFilter = bucket;
            const assignments = chartDataCache.reasonAssignments || [];
            const idsInBucket = new Set(assignments.filter((a) => a.bucket === bucket).map((a) => a.id));
            const filtered = (chartDataCache.latest || []).filter((r) => idsInBucket.has(r.id));
            renderLatestRefusals(filtered);
          }
          // Re-render top signals to update active state
          renderTopSignals(chartDataCache, chartDataCache);
        });
      });
    };

    const renderLatestRefusals = (latest = []) => {
      if (!latest.length) {
        latestRefusals.innerHTML = '<div class="analyst-meta">No items.</div>';
        return;
      }
      latestRefusals.innerHTML = latest
        .map((r) => {
          const flags = r.feature_flags || {};
          const tags = [
            flags.has_attachments ? 'attach' : null,
            flags.has_urls ? 'urls' : null,
            flags.has_ip_based_urls ? 'ip' : null,
            flags.has_mismatched_urls ? 'mismatch' : null
          ].filter(Boolean).join(', ');
          const gmailLink = r.gmail_link
            ? `<a href="${r.gmail_link}" target="_blank" class="notif-link">Open</a>`
            : '';

          return `
            <div class="notification-card">
              <div class="notif-row">
                <span><span class="notif-label">From:</span>${escapeHtml(r.from || 'unknown')}</span>
                <span><span class="notif-label">Time:</span>${fmtTimeShort(r.decided_at)}</span>
              </div>
              <div class="notif-row">
                <span><span class="notif-label">Conf:</span>${r.confidence ?? 'n/a'}</span>
                <span>${tags}</span>
              </div>
              <div class="notif-field subject">
                <span class="notif-label">Subject:</span>
                <span class="notif-value">${escapeHtml(r.subject || 'No subject')}</span>
              </div>
              <div class="notif-field reason">
                <span class="notif-label">Reason:</span>
                <span class="notif-value">${escapeHtml(r.reason || '')}</span>
              </div>
              <div class="notif-footer">
                <span class="notif-id"></span>
                ${gmailLink}
              </div>
            </div>
          `;
        })
        .join('');
    };

    const loadRefusalAnalytics = async () => {
      analystStatus.textContent = '';
      analystStatus.style.color = 'var(--muted)';
      updateWindowLabel();
      chartDrillStack = [];
      if (chartBackBtn) chartBackBtn.disabled = true;
      if (chartRangeLabel) chartRangeLabel.textContent = '';
      // Clear bucket data and filter when filters change - user must re-bucket
      if (reasonBucketsStatus) reasonBucketsStatus.textContent = '';
      activeBucketFilter = null;
      try {
        const params = buildFilterParams();
        const res = await fetch(`/api/analytics/refusals?${params.toString()}`);
        const data = await res.json();
        const total = data.total || 0;
        if (analystTitle) {
          analystTitle.textContent = `Filtered ${total} refusals`;
        }

        // Auto-select model based on count
        const opusMax = analystState.cfg.analyst_max_items_opus || 200;
        if (total <= opusMax) {
          modelSelect.value = 'opus';
        } else {
          modelSelect.value = 'sonnet';
        }
        updateModelMaxLabel();

        renderBuckets(data.buckets || []);
        // Clear reason buckets - pass empty bucket data to show the bucket button
        renderTopSignals(data, {});
        renderLatestRefusals(data.latest || []);
        // Store data but clear any previous bucket results
        chartDataCache = { ...data, reasonBuckets: [], reasonAssignments: [] };
        if (chartSelect) renderChart(chartSelect.value, chartDataCache);
        analystState.refusalsLoaded = true;
      } catch (e) {
        console.error('Analytics fetch failed', e);
        analystStatus.textContent = 'Failed to load refusals';
        analystStatus.style.color = 'var(--danger)';
        analystState.refusalsLoaded = false;
      }
    };

    const setGeminiFallbackMode = (active) => {
      if (active) {
        runClaudeBtn.textContent = 'Run Gemini analysis';
        runClaudeBtn.classList.add('gemini-fallback');
        modelSelect.value = 'gemini';
        updateModelMaxLabel();
      } else {
        runClaudeBtn.textContent = 'Run analysis';
        runClaudeBtn.classList.remove('gemini-fallback');
      }
    };

    const runClaudeAnalysis = async (forceGemini = false) => {
      // Don't overwrite analyst-status - show running state in claude-meta instead
      const selectedModel = forceGemini ? 'gemini' : modelSelect.value;
      claudeMeta.textContent = `Running ${selectedModel}...`;
      // Show the output content area
      claudeOutputContent.style.display = 'block';
      copyOutputBtn.disabled = true;
      claudeOutputRendered.innerHTML = '<span style="color:var(--muted);">Running analysis...</span>';
      claudeOutputRaw.textContent = 'Running analysis...';
      applyViewToggle();
      updateWindowLabel();
      const startHoursRaw = Number(startHoursInput.value);
      const startDaysRaw = Number(startDaysInput.value);
      const endHoursRaw = Number(endHoursInput.value);
      const endDaysRaw = Number(endDaysInput.value);
      const startHoursVal = Number.isFinite(startHoursRaw) ? Math.max(0, Math.min(startHoursRaw, 24 * 60)) : 0;
      const startDaysVal = Number.isFinite(startDaysRaw) ? Math.max(0, Math.min(startDaysRaw, 60)) : 0;
      const endHoursVal = Number.isFinite(endHoursRaw) ? Math.max(0, Math.min(endHoursRaw, 24 * 60)) : 0;
      const endDaysVal = Number.isFinite(endDaysRaw) ? Math.max(0, Math.min(endDaysRaw, 60)) : 0;
      const filters = {};
      if (reasonFilter.value) filters.reason_includes = reasonFilter.value;
      if (subjectFilter.value) filters.subject_includes = subjectFilter.value;
      if (fromFilter.value) filters.from_includes = fromFilter.value;
      if (domainFilter.value) filters.domain_includes = domainFilter.value;
      if (minConf.value) filters.min_confidence = minConf.value;
      if (maxConf.value) filters.max_confidence = maxConf.value;
      if (removedSection.value) filters.removed_section = removedSection.value;
      if (hasAttachments.checked) filters.has_attachments = true;
      if (hasUrls.checked) filters.has_urls = true;
      if (hasIpUrls.checked) filters.has_ip_based_urls = true;
      if (hasMismatch.checked) filters.has_mismatched_urls = true;
      const limit = updateModelMaxLabel();
      const payload = {
        model: selectedModel,
        max_items: limit,
        start_hours: Math.max(1, startHoursVal + startDaysVal * 24),
        end_hours: endHoursVal + endDaysVal * 24,
        filters
      };
      try {
        const res = await fetch('/api/analysis/claude', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok || data.ok === false) {
          const msg = data.error || 'Analysis failed';
          // Check if this is a token limit error and Gemini is available
          const isTokenError = msg.includes('too long') || msg.includes('token') || msg.includes('maximum');
          const geminiAvailable = analystState.cfg.gemini_available && selectedModel !== 'gemini';
          if (isTokenError && geminiAvailable) {
            // Fallback to Gemini
            claudeMeta.textContent = 'Token limit exceeded, retrying with Gemini...';
            setGeminiFallbackMode(true);
            return runClaudeAnalysis(true);
          }
          claudeMeta.textContent = 'Error';
          claudeOutputRendered.innerHTML = `<span style="color:var(--danger);">${escapeHtml(msg)}</span>`;
          claudeOutputRaw.textContent = msg;
          return;
        }
        const providerLabel = data.provider === 'gemini' ? 'Gemini' : data.model;
        claudeMeta.textContent = `${providerLabel} · ${data.count} cases · ${data.window_hours || '?'}h`;
        const outputText = data.result || '(empty response)';
        claudeOutputRendered.innerHTML = renderMarkdown(outputText);
        claudeOutputRaw.textContent = outputText;
        copyOutputBtn.disabled = false;
        // If we used Gemini fallback, keep the button in fallback mode
        if (data.provider === 'gemini' && selectedModel === 'gemini' && forceGemini) {
          setGeminiFallbackMode(true);
        }
      } catch (e) {
        console.error('Analysis failed', e);
        claudeMeta.textContent = 'Error';
        claudeOutputRendered.innerHTML = '<span style="color:var(--danger);">Analysis call failed</span>';
        claudeOutputRaw.textContent = 'Analysis call failed';
      }
    };

    // Gmail Token Refresh Modal Functions
    const showModalStatus = (message, type = 'info') => {
      gmailModalStatus.textContent = message;
      gmailModalStatus.className = `modal-status visible ${type}`;
    };

    const hideModalStatus = () => {
      gmailModalStatus.className = 'modal-status';
    };

    const openGmailModal = async () => {
      gmailModal.classList.add('active');
      gmailCodeInput.value = '';
      hideModalStatus();
      gmailAuthUrl.innerHTML = 'Loading authorization URL...';

      try {
        const res = await fetch('/api/gmail/auth-url');
        const data = await res.json();
        if (data.ok && data.auth_url) {
          gmailAuthUrl.innerHTML = `<a href="${data.auth_url}" target="_blank">${data.auth_url}</a>`;
        } else {
          gmailAuthUrl.innerHTML = `<span style="color:var(--danger);">Error: ${data.error || 'Failed to get auth URL'}</span>`;
        }
      } catch (err) {
        gmailAuthUrl.innerHTML = `<span style="color:var(--danger);">Error: ${err.message}</span>`;
      }
    };

    const closeGmailModal = () => {
      gmailModal.classList.remove('active');
      hideModalStatus();
    };

    const submitGmailCode = async () => {
      const code = gmailCodeInput.value.trim();
      if (!code) {
        showModalStatus('Please paste the authorization code or redirect URL', 'error');
        return;
      }

      showModalStatus('Validating token...', 'info');
      gmailSubmitCode.disabled = true;

      try {
        const res = await fetch('/api/gmail/exchange-token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code })
        });
        const data = await res.json();

        if (data.ok) {
          showModalStatus(`Success! ${data.message}`, 'success');
          // Auto-close after success
          setTimeout(() => {
            closeGmailModal();
          }, 2500);
        } else {
          showModalStatus(`Error: ${data.error}`, 'error');
        }
      } catch (err) {
        showModalStatus(`Error: ${err.message}`, 'error');
      } finally {
        gmailSubmitCode.disabled = false;
      }
    };

    // Wire up notifications collapse toggle
    const toggleNotifications = () => {
      notificationsSection?.classList.toggle('collapsed');
    };
    notificationsHeader?.addEventListener('click', toggleNotifications);

    // Wire up refusals collapse toggle
    const toggleRefusals = () => {
      const wasCollapsed = refusalsSection?.classList.contains('collapsed');
      refusalsSection?.classList.toggle('collapsed');
      // Load refusals when expanding if not already loaded
      if (wasCollapsed && !analystState.refusalsLoaded) {
        loadRefusalAnalytics();
      }
    };
    refusalsHeader?.addEventListener('click', toggleRefusals);

    // Wire up advanced filters collapse toggle
    const toggleAdvancedFilters = () => {
      advancedFilters?.classList.toggle('collapsed');
      advancedFiltersToggle?.classList.toggle('collapsed');
    };
    advancedFiltersToggle?.addEventListener('click', toggleAdvancedFilters);

    // Wire up modal events
    gmailModalClose?.addEventListener('click', closeGmailModal);
    gmailModalCancel?.addEventListener('click', closeGmailModal);
    gmailSubmitCode?.addEventListener('click', submitGmailCode);
    gmailModal?.addEventListener('click', (e) => {
      if (e.target === gmailModal) closeGmailModal();
    });

    const wireAnalystControls = () => {
      const toggleAnalyst = () => {
        const wasCollapsed = analystSection?.classList.contains('collapsed');
        analystSection?.classList.toggle('collapsed');
        analystState.enabled = wasCollapsed;
        if (wasCollapsed) {
          loadRefusalAnalytics();
        }
      };
      analystHeader?.addEventListener('click', toggleAnalyst);

      viewRenderedBtn?.addEventListener('click', () => {
        analystState.view = 'rendered';
        applyViewToggle();
      });

      viewRawBtn?.addEventListener('click', () => {
        analystState.view = 'raw';
        applyViewToggle();
      });

      chartSelect?.addEventListener('change', (e) => {
        const val = e.target.value;
        chartDrillStack = [];
        renderChart(val, chartDataCache);
      });

      chartBackBtn?.addEventListener('click', () => {
        chartDrillStack.pop();
        renderChart(chartSelect?.value || 'none', chartDataCache);
      });

      document.querySelectorAll('[data-step-start-hours]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const step = Number(btn.getAttribute('data-step-start-hours')) || 0;
          startHoursInput.value = Math.max(0, Math.min((Number(startHoursInput.value) || 0) + step, 24 * 60));
          updateWindowLabel();
          chartDrillStack = [];
          if (chartBackBtn) chartBackBtn.disabled = true;
          if (chartRangeLabel) chartRangeLabel.textContent = '';
        });
      });

      document.querySelectorAll('[data-step-start-days]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const step = Number(btn.getAttribute('data-step-start-days')) || 0;
          startDaysInput.value = Math.max(0, Math.min((Number(startDaysInput.value) || 0) + step, 60));
          updateWindowLabel();
          chartDrillStack = [];
          if (chartBackBtn) chartBackBtn.disabled = true;
          if (chartRangeLabel) chartRangeLabel.textContent = '';
        });
      });

      document.querySelectorAll('[data-step-end-hours]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const step = Number(btn.getAttribute('data-step-end-hours')) || 0;
          endHoursInput.value = Math.max(0, Math.min((Number(endHoursInput.value) || 0) + step, 24 * 60));
          updateWindowLabel();
          chartDrillStack = [];
          if (chartBackBtn) chartBackBtn.disabled = true;
          if (chartRangeLabel) chartRangeLabel.textContent = '';
        });
      });

      document.querySelectorAll('[data-step-end-days]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const step = Number(btn.getAttribute('data-step-end-days')) || 0;
          endDaysInput.value = Math.max(0, Math.min((Number(endDaysInput.value) || 0) + step, 60));
          updateWindowLabel();
          chartDrillStack = [];
          if (chartBackBtn) chartBackBtn.disabled = true;
          if (chartRangeLabel) chartRangeLabel.textContent = '';
        });
      });

      modelSelect?.addEventListener('change', () => {
        updateModelMaxLabel();
        // Reset fallback mode when user manually changes model
        runClaudeBtn.textContent = 'Run analysis';
        runClaudeBtn.classList.remove('gemini-fallback');
      });

      loadAnalyticsBtn?.addEventListener('click', loadRefusalAnalytics);
      runClaudeBtn?.addEventListener('click', runClaudeAnalysis);
      updateWindowLabel();
      updateModelMaxLabel();

      copyOutputBtn?.addEventListener('click', async () => {
        const text = analystState.view === 'raw'
          ? claudeOutputRaw.textContent || ''
          : claudeOutputRendered.textContent || '';
        try {
          await navigator.clipboard.writeText(text);
          const origText = copyOutputBtn.textContent;
          copyOutputBtn.textContent = 'Copied!';
          setTimeout(() => { copyOutputBtn.textContent = origText; }, 1500);
        } catch (err) {
          const origText = copyOutputBtn.textContent;
          copyOutputBtn.textContent = 'Failed';
          setTimeout(() => { copyOutputBtn.textContent = origText; }, 1500);
        }
      });

      reasonBucketsBtn?.addEventListener('click', runReasonBucketing);

      applyViewToggle();
      if (chartArea) chartArea.classList.remove('active');
    };

    let latestConfig = {};

    const refresh = async () => {
      try {
        const res = await fetch('/api/status');
        const data = await res.json();
        latestConfig = data.config_sanitized || {};
        analystState.cfg = latestConfig;
        updateModelMaxLabel();
        const cfg = data.config_sanitized || {};
        renderHealth(data.health || {}, cfg);
        renderStats(data.stats || {});
        renderGpu(data.gpu);
        renderNotifications(data.recent_sends || []);
        if (data.config_sanitized) renderConfig(cfg);
      } catch (e) {
        console.error('Status fetch failed', e);
      }
    };

    wireAnalystControls();
    refresh();
    setInterval(refresh, 2000);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</body>
</html>
